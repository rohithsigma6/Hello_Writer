// let's imagine this file is autogenerated from the backend
// ideally, we want to keep these api related types in sync
// with the backend instead of manually writing them out

import { FilePermission } from '@/store/editor/slices/editor';

export type BaseEntity = {
  id: string;
  createdAt: number;
};

export type Entity<T> = {
  [K in keyof T]: T[K];
} & BaseEntity;

export type Meta = {
  page: number;
  total: number;
  totalPages: number;
};

// export type User = Entity<{
//   firstName: string;
//   lastName: string;
//   email: string;
//   role: 'ADMIN' | 'USER';
//   teamId: string;
//   bio: string;
// }>;

export type AuthResponse = {
  body: { user: User };
};

export type Team = Entity<{
  name: string;
  description: string;
}>;

export type Discussion = Entity<{
  title: string;
  body: string;
  teamId: string;
  author: User;
}>;

export type Comment = Entity<{
  body: string;
  discussionId: string;
  author: User;
}>;

export type Folder = Entity<{
  _id: string;
  userId: string;
  title: string;
  Files: File[];
  createdAt: string;
  updatedAt: string;
  __v: number;
  permissionType?: string;
}>;

export type SnapShotVersion = {
  versionList: {
    _id: string;
    userId: string;
    fileId: string;
    versionHistory: ScreenplayVersion[];
  }[];
};

export type File = Entity<{
  _id: string;
  userId: string;
  title: string;
  genre: string[];
  subgenre: string[];
  secureStatus: boolean;
  createdAt: string;
  updatedAt: string;
  permission: string;
  collaborators: Collaborator[];
  prefix?: string;
  screenplayVersions?: ScreenplayVersion[];
  folderId?: string;
  __v?: number;
  writtenBy?: string[];
  logline?: string;
  theme?: string;
  permissionType?: FilePermission;
  pagetarget: number;
  currentPage: number;
}>;
export type ScreenplayBuffer = {
  type: string;
  data: number[];
};

export interface User {
  _id: string;
  firstName: string;
  lastName: string;
  phoneNo: string;
  email: string;
  googleId: string;
  role: string;
  isAdmin: boolean;
  isVerified: boolean;
  colorCode: string;
  lifetimeRegistered: boolean;
  createdAt: string;
  updatedAt: string;
  __v: number;
  profile_image: string;
  profile?: Profile;
  isEligible?: boolean;
  eligibility?: Eligibility;
  token?: string;
}

export interface ScreenplayVersion {
  userId: string;
  versionName: string;
  versionColor: string;
  editStatus: string;
  screenplay: ScreenplayBuffer;
  _id?: string;
}

export interface Collaborator {
  name?: string;
  email?: string;
  _id?: string;
  resourceId?: string;
  userId: User;
  __v?: number;
  createdAt?: string;
  updatedAt?: string;
  permissionType?: string;
  resourceType?: string;
}

export interface Folders {
  OWNED: Folder[];
  SHARED: Folder[];
  SHAREDBYME: Folder[];
}

export interface Files {
  OWNED: File[];
  SHARED: File[];
  SHAREDBYME: File[];
}

export interface FilesData {
  Files: Files;
}
export interface FoldersData {
  folders: Folders;
}

export interface Profile {
  _id: string;
  userId: string;
  createdAt: string;
  updatedAt: string;
  __v: number;
  personalPreferences: PersonalPreferences;
  professionalInfo: ProfessionalInfo;
}

export interface PersonalPreferences {
  passion: string[];
  otherPassion: string;
  favoriteScreenPlayFormat: string[];
}

export interface ProfessionalInfo {
  primaryGenre: string;
  secondaryGenres: string[];
}

export interface Eligibility {
  inkCredits: number;
  subscriptionId: string;
  features: Features;
}
export interface Features {
  manageWritersRooms: boolean;
  discoverScreenplays: boolean;
  greenlight: boolean;
  breakdowns: boolean;
  shotLists: boolean;
  productionRequirements: boolean;
  onboardCastCrew: boolean;
  contractsManagement: boolean;
  preProductionManagement: boolean;
  budgetScheduleTool: boolean;
  callSheets: boolean;
  dailyProductionReports: boolean;
  eLearningCourses: boolean;
  screenplayLibrary: boolean;
  prewritingTools: boolean;
  intuitiveScreenplayEditor: boolean;
  unlimitedProjects: boolean;
  multilingualSupport: boolean;
  industryStandardFormatting: boolean;
  writingSprintsGoals: boolean;
  aiWritingAssistant: boolean;
  spellGrammarCheck: boolean;
  plotDiagnostics: boolean;
  blockchainScriptRegistry: boolean;
  contestsEngagement: boolean;
  dictationAssistant: boolean;
  ocrFormatting: boolean;
  advancedFormatting: boolean;
  realTimeCollaboration: boolean;
  crowdCollaborativeWriting: boolean;
  peerValidation: boolean;
  scriptCoverage: boolean;
  pitchDeckBuilder: boolean;
  industryMarketPlace: boolean;
  writerRepresentation: boolean;
  directorToolkit: boolean;
  physicalPlottingWriting: boolean;
  audioVideoConferencing: boolean;
  smartPenIntegration: boolean;
  tableRead: boolean;
  screenplayAudioBook: boolean;
  scriptDoctoring: boolean;
  screenplayReports: boolean;
  storyBoards: boolean;
  translateScreenplays: boolean;
  transliterateScreenplays: boolean;
  advancedDirectorToolkit: boolean;
  trackPitches: boolean;
  earnOnPlatform: boolean;
}

export type SearchUser = Entity<{
  name: string;
  email: string;
  _id: string;
}>;

enum PermissionType {
  Edit = 'Edit',
  Suggest = 'Suggest',
  View = 'View',
  Comment = 'Comment',
  Admin = 'Admin',
}

export type CollaboratorPayload = {
  email: string | undefined;
  permissionType?:
  | PermissionType.Edit
  | PermissionType.Suggest
  | PermissionType.View
  | PermissionType.Comment
  | PermissionType.Admin;
  name: string | undefined;
  profile?: string | undefined;
  editable?: boolean;
  userId: string | undefined | null;
};

export type CreateFilePayload = {
  title: string;
  genre: string[];
  subTitle: string;
  basedOn: string;
  subgenre: string[];
  collaborators: CollaboratorPayload[];
  typeOfCreation: string;
  logline: string;
  theme: string;
  pagetarget: string;
  folderId?: string;
};

// enum PermissionType {
//   VIEW = 'VIEW',
//   SUGGEST = 'SUGGEST',
//   EDIT = 'EDIT',
// }

interface FolderCollaborator {
  userId: string;
  permissionType: string;
}

export interface CreateFolderPayload {
  title: string;
  collaborators: FolderCollaborator[];
}

export interface CreateFolderResponse {
  userId: string;
  title: string;
  Files: any[];
  _id: string;
  createdAt: string;
  updatedAt: string;
  __v: number;
}

export interface SignInPayload {
  email: string;
  password: string;
}


export interface ScreenPlayTimer {
  wordCount: number;
  minutesCount: number;
  writingTime: number;
  thinkingTime: number;
  wordGoal: number;
  pageGoal: number;
  sceneGoal: number;
  minutesGoal: number;
  deadline: string;
}

export interface ScreenPlayTimerPayload {
  fileId: string;
  version: string;
  dailyGoal: ScreenPlayTimer
}

